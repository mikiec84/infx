---
title: "JSON object handling"
author: "Nicolas Bennett"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{JSON objects}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The openBIS JSON-RPC API is powered by the Jackson JSON processor on the server side. As such, object type information is communicated via `@type` fields. Take as an example the class `Dog` defined as

```java
public class Dog {
  private String name;
  private String breed;
  // setters and getters
}
```

An instance of `Dog` can be represented as the following JSON object

```json
{
  "@type": "Dog",
  "name": "Rufus",
  "breed": "english shepherd"
}
```

where the `@type` filed is used by the deserializer to infer what java object should result. Furthermore, on the client side, class information is used for S3 method dispatch. This document will illustrate how typed JSON objects returned by openBIS are converted into S3 classes, how these classes can be manipulated in R and subsequently used for further openBIS queries.

## Creating `json_class` objects

Again a feature of the Jackson serializer, `@id` fields are generated for all objects by an `ObjectIdGenerator` (an `IntSequenceGenerator` to be more specific), which can be used to represent relationships among objects. These object ids however do not currently serve any purpose on the client side and are therefore recursively stripped by the function `remove_id()`. This initial action is illustrated, using the object `response`

```{r resp}
response <- list(`@type` = "foobar",
                 `@id` = 1L,
                 a = list(`@type` = "foo",
                          `@id` = 2L,
                          b = "c"),
                 d = list(`@type` = "bar",
                          `@id` = 3L,
                          e = "f"))
response <- remove_id(response)
str(response)
```

Turning a list such as `response` into a `json_class` S3 class can be done, using the function `as_json_class()` (or its alias `as.json_class()`). This action is applied recursively, meaning that all sub-lists, containing an `@type` field are turned into `json_class` objects as well.

```{r as-class}
json_class <- as_json_class(response)
str(json_class)
```

In case the user wants to create `json_class` object, the constructor `json_class()` is available. It can be used as follows, e.g. for the recreation of the above `json_class` object

```{r construct}
construct <- json_class(a = json_class(b = "c", class = "foo"),
                        d = json_class(e = "f", class = "bar"),
                        class = "foobar")
identical(construct, json_class)
```

The effect of `as_json_class()` can be reversed by `rm_json_class()` or `as_list()` (as well as its alias `as.list()`). The two functions differ in default behavior however. Where `rm_json_class()` removes S3 classes and writes class information into the respective `@type` fields, `as_list()`, by default simple returns its input. This somewhat odd choice is owed to the circumstance that iterating though a `json_class` object with `lapply()` or `sapply()` calls `as.list()` on its first argument.

```{r destruct}
identical(response,
          rm_json_class(json_class))
identical(as.list(json_class, keep_asis = FALSE),
          rm_json_class(json_class))
```
