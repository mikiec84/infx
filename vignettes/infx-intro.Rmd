---
title: "Introduction to infx"
author: "Nicolas Bennett"
date: "`r Sys.Date()`"
output:
  html_vignette:
    self_contained: no
vignette: >
  %\VignetteIndexEntry{Introduction to infx}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(infx)
```

OpenBIS (Open Biology Information System) is a laboratory information management system designed for robust data management of large-scale experiments in biological sciences. As storage infrastructure it is therefore well suited for the needs of the image-based high throughput screening (HTS) performed by the InfectX consortium. For data access, JSON-RPC services are provided by openBIS, which can be called from the presented client package `infx`.

This document gives a short introduction to some basic concepts of the openBIS architecture with a focus on aspects relevant to HTS and provides some examples of how the `infx` can be used to access various types of data generated by the InfectX experiments. For more information, general openBIS documentation is available [here](https://wiki-bsse.ethz.ch/display/openBISDoc1304/openBIS) and documentation specific to the JSON-RPC API can be accessed form [here](https://wiki-bsse.ethz.ch/display/openBISDoc1304/openBIS+JSON+API). It might help to have a look at the browser-based web GUI  available [here](https://infectx.biozentrum.unibas.ch/openbis) alongside this document to help familiarizing with the presented concepts.

## Organizational concepts in OpenBIS 

An organizational entity central to the openBIS storage logic is an **experiment**. In the context of InfectX, an experiment is a single screen, meaning the combination of a compound library and an experimental condition provided by the presence of a pathogen. For example in the experiment `ADENO-AU-K1`, a kinome-wide siRNA library by Ambion (Silencer Select) was applied in unpooled fashion (3 siRNAs per gene), alongside exposure to the pathogen Adenovirus.

Experiments are grouped into **projects** (one per pathogen in the case of InfectX), which in turn are grouped into **spaces** (an unimportant hierarchical level for InfectX). Projects can be listed using `list_projects()` and experiments with `list_experiments()`.

```{r exp-proj}
token <- login_openbis("rdgr2014", "IXPubReview")

projects <- list_projects(token)

length(projects)
print(projects[[1]])

adeno_exps <- list_experiments(token, projects[[1]])

length(adeno_exps)
print(adeno_exps[[1]])

str(adeno_exps[[1]]$properties)
```

In order to access the API, a login token has to be created. Using this token, all available projects are listed using `list_projects()` and all experiments
corresponding to a project are listed with `list_experiments()`. Some information on the individual experiments is available in the `properties` entry.

Experiments in high-throughput screening are typically carried out on microtiter plates which lends itself to a natural way of sub-dividing individual experiments. All InfectX screens were preformed on 384 well plates, composed of 16 rows (A through P) and 24 columns (1 through 24) and each plate can be uniquely identified by a barcode.

```{r plate-well}
plates <- list_plates(token, adeno_exps[[1]])

length(plates)
print(plates[[2]])

wells <- list_wells(token, plates[[2]])

length(wells)
print(wells[1:2], depth = 2)
```

The functions for listing plates and wells are `list_plates()` and `list_wells()`, respectively. The above example shows how for a single experiment, all associated plates and for a single plate, all contained wells can be retrieved.

In terms of openBIS entities, both a plate and a well are considered **samples**. A sample is described as follows by the [openBIS user documentation](https://wiki-bsse.ethz.ch/display/openBISDoc1304/openBIS+User+Documentation#openBISUserDocumentation-Introduction):

> A sample refers to any object that has been observed, measured, or compared to another. It must be uniquely identifiable, which means that any two samples must be distinguishable from one another. Please note that different use cases may use the term "sample" with slightly different meanings, dependent upon the context and utility. ... [T]he term "sample" could [for example] refer to an individual well in a multi-titer plate containing cells of different phenotypes.

The function `list_samples()` retrieves `Sample` objects, which generalize `PlateIdentifier` and `WellIdentifier` objects. As with many other `infx` functions, `list_samples()` is an S3 generic function. If dispatch occurs on an `Experiment` object, the set of plate samples belonging to an experiment is fetched, as with `list_plates()`. Well samples per plate cannot be directly listed as was the case with `list_wells()`. However `list_samples()` dispatched on a set of `WellIdentifier` objects will return the corresponding well samples.

```{r sample}
plate_samp <- list_samples(token, adeno_exps[[1]])

length(plate_samp)
print(plate_samp[[2]])

wells_samp <- list_samples(token, wells[1:2])

print(wells_samp)
```

The sample type is encoded in the `sampleTypeCode` field of each `Sample` object and an exhaustive list of available sample types can be shown using `list_sample_types()`.

A further important organizational concept of openBIS is that of a **data set**. On this entity, the [openBIS user documentation](https://wiki-bsse.ethz.ch/display/openBISDoc1304/openBIS+User+Documentation#openBISUserDocumentation-Introduction) notes the following:

> A data set is the computer's representation of a series of sample measurements, or the results of computational processing derived from those measurements. As with samples and experiments, data sets also have specific data set types to better handle searching and analysis needs.

Essentially, a data set represents a collection of files associated with a sample. Furthermore data sets may have (multiple) parent/child relationships among each other, to indicate one data set being derived of another. Retrieving all data sets belonging to a plate can be achieved with calling `list_datasets()` on plate sample objects.

```{r data-set}
data_sets <- list_datasets(token, plate_samp[[2]])

length(data_sets)
print(data_sets[[1]])

unique(sapply(data_sets, `[[`, "dataSetTypeCode"))

list_datasets(token, wells_samp[[1]])
```

Several different types of data sets (possibly in multiple versions) are typically associated with a plate. Some of the more interesting data set types are

* `HCS_IMAGE_CONTAINER_RAW`: raw imaging data, 6-9 images per well each available for 3-4 imaging channels
* `HCS_IMAGE_CONTAINER_SEGMENTATION`: image overlays for segmenting images into cells, nuclei, etc.
* `HCS_ANALYSIS_IMAGE_ACQUISITION_METADATA`: microscope image meta data and settings
* `HCS_ANALYSIS_CELL_FEATURES_CC_MAT`: CellProfiler feature data at single cell resolution
* `HCS_ANALYSIS_CELL_CLASSIFICATIONS_MAT`: decision tree-based infection scoring data

The way openBIS is set up for InfectX, data sets are only available on the plate sample level and not per well, as is demonstrated by passing a well sample object to `list_datasets()`, which returns an empty list.

## Searching in OpenBIS 

Search queries for OpenBIS are constructed with `search_criteria()` and the search is executed by calling `search_openbis()`. The function `search_criteria()` instantiates a `SearchCriteria` object which consists of a set of match clauses combined with either an `any` or `all` operator. Nesting of `SearchCriteria` objects is possibly by supplying a `SearchCriteria` object as `sub_criteria` argument to a call to `search_criteria()`, in turn creating the enclosing `SearchCriteria` object.

Five different types of match clauses can be constructed:

* `PropertyMatchClause`: A `MatchClause` for checking that a property equals a desired value.
* `AnyPropertyMatchClause`: A `MatchClause` for checking that any of the properties equals a desired value.
* `AnyFieldMatchClause`: A `MatchClause` for checking that any of the properties or attributes equals a desired value.
* `AttributeMatchClause`: A `MatchClause` for checking that an attribute equals a desired value.
* `TimeAttributeMatchClause`: A `MatchClause` for comparing a time attribute to a specified value.

For every match clause, a desired value has to be supplied, as well as a comparison mode which can either be `eq` (equal to), `lte` (less than or equal to) or `gte` (greater than or equal to). Additionally, for a `PropertyMatchClause`, a property code (possibilities can be enumerated with `list_property_types()`) has to be specified, for an `AttributeMatchClause`, an attribute^[possible values are `code`, `type`, `perm_id`, `space`, `project`, `project_perm_id`, `metaproject`, `registrator_user_id`, `registrator_first_name`, `registrator_last_name`, `registrator_email`, `modifier_user_id`, `modifier_first_name`, `modifier_last_name` or `modifier_email`] and for a `TimeAttributeMatchClause`, a time attribute (either `registration_date` or `modification_date`).
