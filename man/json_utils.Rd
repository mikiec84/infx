% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/json-class.R, R/json-utils.R, R/json-vec.R
\name{has_fields.json_class}
\alias{has_fields.json_class}
\alias{get_field.json_class}
\alias{has_subclass.json_class}
\alias{get_subclass.json_class}
\alias{has_fields}
\alias{has_fields.default}
\alias{get_field}
\alias{has_subclass}
\alias{has_subclass.default}
\alias{get_subclass}
\alias{get_subclass.list}
\alias{remove_null}
\alias{has_fields.json_vec}
\alias{get_field.json_vec}
\alias{has_subclass.json_vec}
\alias{get_subclass.json_vec}
\title{JSON class utilities}
\usage{
\method{has_fields}{json_class}(x, fields, ...)

\method{get_field}{json_class}(x, field, ...)

\method{has_subclass}{json_class}(x, class, ...)

\method{get_subclass}{json_class}(x)

has_fields(x, fields, ...)

\method{has_fields}{default}(x, ...)

get_field(x, field, ...)

has_subclass(x, class, ...)

\method{has_subclass}{default}(x, ...)

get_subclass(x)

\method{get_subclass}{list}(x, ...)

remove_null(x)

\method{has_fields}{json_vec}(x, fields, ...)

\method{get_field}{json_vec}(x, field, ...)

\method{has_subclass}{json_vec}(x, class, ...)

\method{get_subclass}{json_vec}(x, ...)
}
\arguments{
\item{x}{Object to test.}

\item{fields}{Character vector of nonzero length, holding the field names
for which to check.}

\item{...}{Generic compatibility.}

\item{field}{Character vector of length 1, holding the field name to
extract.}

\item{class}{Character vector of nonzero length, holding the class names
to test for.}
}
\description{
Several utility functions for working with \code{json_class} and \code{json_vec}
objects are provided. This includes \code{has_fields()} for checking whether
certain fields are available in an object, \code{get_field()} to extract
values from an object that correspond to a field with a certain name,
\code{has_subclass()} for testing that an object is of a certain class and
\code{get_subclass()} to extract this class. Finally, NULL fields can be
recursively removed using \code{remove_null()}. More information is available
in the details section.
}
\details{
The generic function \code{has_fields()} tests whether a single \code{json_class}
object contains all of the specified fields or whether each \code{json_class}
object contained in a \code{json_vec} object passes this test. If dispatch
occurs on an object that is neither of class \code{json_class}, nor of class
\code{json_vec}, \code{has_fields()} returns \code{FALSE}. A single field can be extracted
from a \code{json_class} or a \code{json_vec} object, using \code{get_field()}. Iteration
for \code{json_vec} objects happens via \code{\link[base:sapply]{base::sapply()}} so that when possible
the result is simplified.

In order to test whether a \code{json_class} or a \code{json_vec}  object is of a
certain sub-class (can also be a vector of sub-classes), the generic
function \code{has_subclass()} can be used. Dispatch on objects that do not
inherit from either \code{json_class} or \code{json_vec} will return \code{FALSE}. The
sub-class of a \code{json_class} or a \code{json_vec} object can be determined, using
\code{get_subclass}. This will also work if dispatched on a \code{list} of objects if
that list object passes \code{\link[=has_common_subclass]{has_common_subclass()}}.

The function \code{remove_null()} recursively removes all NULL fields from a
nested list structure while preserving \code{json_class} and \code{json_vec} class
attributes. This can be useful when fetching an object form openBIS and
subsequently using this object for a further query: whenever the object
returned by the first API call contains NULL fields, it is safer to remove
all of them, as in some cases this might cause an error in the following
API requests.
}
\examples{
obj_1 <- json_class(a = 1, b = 2, class = "foo")
obj_2 <- json_class(a = 2, b = 4, class = "foo")
obj_3 <- json_class(a = 3, c = 6, class = "foo")

# one or more fields can be tested
has_fields(obj_1, "a")
has_fields(obj_1, c("a", "b"))
# dispatch on json_vec objects is possible as well
has_fields(c(obj_1, obj_2), "a")
has_fields(c(obj_1, obj_2), "b")
has_fields(c(obj_1, obj_3), "b")
has_fields(c(obj_1, obj_3), c("a", "b"))
# other types do not pass the test
has_fields(list(obj_1, obj_3), "a")

get_field(obj_1, "a")
get_field(c(obj_1, obj_3), "a")
\dontrun{
  # the requested field must be available in every instance
  get_field(c(obj_1, obj_3), "b")
  # only a single field may be requested
  get_field(c(obj_1, obj_2), c("a", "b"))
}

obj_4 <- json_class(a = 4, c = 8, class = "bar")

# dispatch on json_class
has_subclass(obj_1, "foo")
# dispatch on json_vec
has_subclass(c(obj_1, obj_2), "foo")
# dispatch on other object types always returns FALSE
has_subclass(list(obj_1, obj_2), "foo")

# dispatch on json_class
get_subclass(obj_1)
# dispatch on json_vec
get_subclass(c(obj_1, obj_2))
# dispatch on list is possible if the list passes has_common_subclass()
get_subclass(list(obj_1, obj_2))
\dontrun{
  get_subclass(list(obj_1, obj_4))
}

tmp <- json_class(a = json_class(b = "c", d = NULL, class = "foo"),
                  e = json_class(f = "g", class = "bar"),
                  h = NULL,
                  class = "foobar")
print(tmp, 2)
print(remove_null(tmp), 2)

}
\seealso{
Other json object handling functions: \code{\link{json_class}},
  \code{\link{json_vec}}, \code{\link{print.json_class}}
}
\concept{json object handling functions}
