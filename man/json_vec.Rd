% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/json-vec.R
\name{json_vec}
\alias{json_vec}
\alias{as_json_vec}
\alias{as.json_vec}
\alias{as_json_vec.json_vec}
\alias{as_json_vec.json_class}
\alias{as_json_vec.list}
\alias{as_json_vec.default}
\alias{as.list.json_vec}
\alias{is_json_vec}
\alias{is.json_vec}
\alias{has_common_subclass}
\title{Construct and validate JSON object vectors}
\usage{
json_vec(...)

as_json_vec(x, ...)

as.json_vec(x, ...)

\method{as_json_vec}{json_vec}(x, ...)

\method{as_json_vec}{json_class}(x, ...)

\method{as_json_vec}{list}(x, recursive = FALSE, force = FALSE, ...)

\method{as_json_vec}{default}(x, force = FALSE, ...)

\method{as.list}{json_vec}(x, ...)

is_json_vec(x)

is.json_vec(x)

has_common_subclass(x)
}
\arguments{
\item{...}{Individual \code{json_class} objects, or generic compatibility}

\item{x}{A single/list of \code{json_class} object(s), or other object to coerce}

\item{recursive}{Recursively apply the function.}

\item{force}{Suppress error when casting an object to \code{json_vec} that
cannot be converted.}
}
\description{
In order to allow method dispatch on a set of \code{json_class} objects without
resorting to iterating over the individual set members, vectors of
\code{json_class} objects are wrapped by a \code{json_vec} class. Iterating over
objects is is some cases inefficient because the openBIS API can for some
functions accept lists of objects. Assembling multiple \code{json_class} objects
as a list in R however breaks method dispatch, as the type of this object
is \code{list} instead of the desired \code{json_class} sub-class. A \code{json_vec} object
therefore represents a list of \code{json_class} objects of the same sub-class
and brings this sub-class to the surface of the compound object.
}
\details{
A \code{json_vec} object can be instantiated using the \code{json_vec()} constructor
which takes a list of \code{json_class} objects of the same sub-class. An
existing list of \code{json_class} objects can be coerced to \code{json_vec} using
\code{as_json_vec()}/\code{as.json_vec()} and applying \code{as_list()}/\code{as.list()} to a
\code{json_vec} object reverses the action of \code{as_json_vec()} by removing all
\code{json_vec} related class information.

The function \code{is_json_vec()} and its alias \code{is.json_vec()} can be used to
test whether an object is a proper \code{json_vec} object. This requires that
\itemize{
\item all child elements have to be of the same sub-class
\item all child elements are required to be properly formed \code{json_class}
objects
\item the \code{json_vec} class attribute has to be in last position
\item the remaining class attributes have to be equal to the common sub-class
determined for the children.
}

Testing whether a list structure consists of \code{json_class} objects which are
of the same sub-class can be done with \code{has_common_subclass()}. This always
returns \code{TRUE} if a \code{json_class} object is passed and \code{FALSE} if a non-list
structure is passed.
}
\examples{
a <- json_class(field = "a", class = "foo")
b <- json_class(field = "b", class = "foo")

ab <- json_vec(a, b)

print(ab)

identical(ab, as_json_vec(list(a, b)))
# as_json_vec() is idempotent
identical(as_json_vec(list(a, b)),
          as_json_vec(as_json_vec(list(a, b))))

# a json_class object can be turned into a json_vec of length 1
ab_class <- json_class(foo1 = a, foo2 = b, class = "bar")
length(ab_class)
ab_vec <- as_json_vec(ab_class)
length(ab_vec)
# this can be reversed using as_json_class()
identical(ab_class, as_json_class(ab_vec))

# has_common_subclass() will alway return true for json_class objects
has_common_subclass(a)
# list-based objects are tested
has_common_subclass(list(a, b))
# this includes json_vec objects
has_common_subclass(ab)
# each list entry has to be a json_class object
has_common_subclass(list("a", "b"))
# here sub-classes are "foo" and "bar"
has_common_subclass(list(ab_class, a))

is_json_vec(a)
is_json_vec(list(a, b))
is_json_vec(ab)

}
