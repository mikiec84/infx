% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/file.R
\name{list_files}
\alias{list_files}
\alias{list_files.character}
\alias{list_files.DataSet}
\alias{list_files.DatasetIdentifier}
\alias{list_files.DatasetReference}
\alias{list_files.FeatureVectorDatasetReference}
\alias{list_files.FeatureVectorDatasetWellReference}
\alias{list_files.ImageDatasetReference}
\alias{list_files.MicroscopyImageReference}
\alias{list_files.PlateImageReference}
\alias{list_files.DataSetFileDTO}
\alias{fetch_files}
\alias{fetch_files.character}
\alias{fetch_files.NULL}
\alias{fetch_files.DataSet}
\alias{fetch_files.DatasetIdentifier}
\alias{fetch_files.DatasetReference}
\alias{fetch_files.FeatureVectorDatasetReference}
\alias{fetch_files.FeatureVectorDatasetWellReference}
\alias{fetch_files.ImageDatasetReference}
\alias{fetch_files.MicroscopyImageReference}
\alias{fetch_files.PlateImageReference}
\alias{fetch_files.DataSetFileDTO}
\alias{fetch_files.FileInfoDssDTO}
\alias{read_mat_files}
\title{List and download files}
\usage{
list_files(token, x, ...)

\method{list_files}{character}(token, x, path = "", recursive = TRUE,
  ...)

\method{list_files}{DataSet}(token, x, path = "", recursive = TRUE,
  ...)

\method{list_files}{DatasetIdentifier}(token, x, path = "",
  recursive = TRUE, ...)

\method{list_files}{DatasetReference}(token, x, path = "",
  recursive = TRUE, ...)

\method{list_files}{FeatureVectorDatasetReference}(token, x, path = "",
  recursive = TRUE, ...)

\method{list_files}{FeatureVectorDatasetWellReference}(token, x,
  path = "", recursive = TRUE, ...)

\method{list_files}{ImageDatasetReference}(token, x, path = "",
  recursive = TRUE, ...)

\method{list_files}{MicroscopyImageReference}(token, x, path = "",
  recursive = TRUE, ...)

\method{list_files}{PlateImageReference}(token, x, path = "",
  recursive = TRUE, ...)

\method{list_files}{DataSetFileDTO}(token, x, ...)

fetch_files(token, x, ...)

\method{fetch_files}{character}(token, x, files = NULL, n_con = 5L,
  reader = identity, ...)

\method{fetch_files}{NULL}(token, x, files, n_con = 5L,
  reader = identity, ...)

\method{fetch_files}{DataSet}(token, x, ...)

\method{fetch_files}{DatasetIdentifier}(token, x, ...)

\method{fetch_files}{DatasetReference}(token, x, ...)

\method{fetch_files}{FeatureVectorDatasetReference}(token, x, ...)

\method{fetch_files}{FeatureVectorDatasetWellReference}(token, x, ...)

\method{fetch_files}{ImageDatasetReference}(token, x, ...)

\method{fetch_files}{MicroscopyImageReference}(token, x, ...)

\method{fetch_files}{PlateImageReference}(token, x, ...)

\method{fetch_files}{DataSetFileDTO}(token, x, ...)

\method{fetch_files}{FileInfoDssDTO}(token, x, data_sets = NULL, ...)

read_mat_files(data)
}
\arguments{
\item{token}{Login token as created by \code{login_openbis()}.}

\item{x}{Object to limit search for datasets/files with.}

\item{...}{Generic compatibility. Extra arguments will be passed to
\code{\link[=make_requests]{make_requests()}} or \code{\link[=do_requests_serial]{do_requests_serial()}}/\code{\link[=do_requests_parallel]{do_requests_parallel()}}.}

\item{path}{A (vector of) file path(s) to be searched within a dataset.}

\item{recursive}{A (vector of) logicals, indicating whether to list files
recursively.}

\item{files}{Optional set of \code{FileInfoDssDTO} objects. If NULL, all files
corresponding to the specified datasets are assumed. This file list can be
filtered, by passing a regular expression as \code{file_regex} argument via
\code{...}.}

\item{n_con}{The number of simultaneous connections.}

\item{reader}{A function to read the downloaded data. Is forwarded as
finally argument to \code{\link[=do_requests_serial]{do_requests_serial()}}/\code{\link[=do_requests_parallel]{do_requests_parallel()}}.}

\item{data_sets}{Either a single dataset object (anything that has a
\code{dataset_code()} method) or a set of objects of the same length as \code{x}. If
\code{NULL} (default), each \code{FileInfoDssDTO} object passed as \code{x} is expected
to contain a \code{data_set} attribute.}

\item{data}{The data to be read.}
}
\description{
A dataset in openBIS represents a collection of files. The function
\code{list_files()} lists files associated with one or more datasets by
returning a set of \code{FileInfoDssDTO} objects. As this object type does not
contain information on data set association, the data set code is saved
as \code{data_set} attribute with each \code{FileInfoDssDTO} object. Data set files
can be fetched using \code{fetch_files()}, which can either retrieve all
associated files or use file path information, for example from
\code{FileInfoDssDTO} objects to only download a subset of files.
}
\details{
Data sets for \code{list_files()} can be specified as character vector of
dataset codes and therefore all objects for which the internal method
\code{\link[=dataset_code]{dataset_code()}} exists can be used to select datasets. This includes data
set and data set id objects as well as the various flavors of data set
reference objects. In addition to these dataset-representing objects,
dispatch on \code{DataSetFileDTO} objects is possible as well.

File listing can be limited to a certain path within the dataset and the
search can be carried out recursively or non-recursively. In case a set of
objects is passed, the search-tuning arguments \code{path} and \code{recursive} have
to be either of length 1 or of the same length as \code{x}. If dispatch occurs
on \code{DataSetFileDTO} objects, the \code{path} and \code{recursive} arguments are not
needed, as this information is already encoded in the objects passed as \code{x}.
A separate API call is necessary for each of the objects the dispatch
occurs on.

The function \code{fetch_files()} downloads files associated with a dataset.
In order to identify a file, both a data set code and a file path, relative
to the data set root, are required. \code{fetch_files()} can be called in a
variety of ways and internally uses a double dispatch mechanism, first
resolving the data set codes and then calling the non-exported function
\code{fetch_ds_files()} which dispatches on file path objects.

Data set code information can either be communicated using any of the
objects understood by \code{\link[=dataset_code]{dataset_code()}} (including data set, data set id and
data set reference objects) or directly as a character vector, passed as
\code{x} argument. In case data set code information is omitted (passed to \code{x}
as \code{NULL}), the objects encoding file paths have to specify the
corresponding data sets. Furthermore, \code{DataSetFileDTO} objects may be
passed as \code{x} argument to \code{fetch_files()}, which will internally call
\code{fetch_files()} again, setting the argument \code{x} to \code{NULL} and pass the
\code{DataSetFileDTO} objects as files argument. Finally, if \code{FileInfoDssDTO}
are passed to \code{fetch_files()} as \code{x} argument, an optional argument
\code{data_sets} may be specified (it defaults to \code{NULL}) and as above,
\code{fetch_files()} is called again with these two arguments rearranged.

The internal generic function \code{fetch_ds_files()} can be dispatched on
several objects again. When no files are specified (\code{NULL} is passed as
\code{files} argument to \code{fetch_files()}), all available files for the given
data sets are queried. This list can be filtered using the \code{file_regex()}
argument which can be a single regular expression and is applied to file
paths. File paths can be specified as character vector, \code{FileInfoDssDTO} or
\code{DataSetFileDTO} objects. If dispatch occurs on \code{FileInfoDssDTO}, and no
data set code information is available (\code{NULL} passed as \code{x} or \code{data_sets}
argument to \code{fetch_files()}) each \code{FileInfoDssDTO} must contain a \code{data_set}
attribute. Additionally, downloaded files are checked for completeness, as
these objects contain file sizes. If dispatch occurs on \code{DataSetFileDTO}
objects or a character vector, this sanity check is not possible.

Files can only be retrieved after previously having created a corresponding
download url using \code{\link[=list_download_urls]{list_download_urls()}}, as file urls in openBIS have a
limited lifetime and therefore must be used shortly after being created. A
list of \code{call} objects (see \code{\link[base:call]{base::call()}}) is created and passed to either
\code{\link[=do_requests_serial]{do_requests_serial()}} or \code{\link[=do_requests_parallel]{do_requests_parallel()}}. Whether file fetching
is carried out in serial or parallel is controlled by the \code{n_con} argument.
In case a download fails, it is retried again up to the number of times
specified as \code{n_try}. Finally, a function with a single argument can be
passed as the argument \code{done}, which takes the downloaded data as input and
does some processing.

A function for reading the binary data retrieved from openBIS can be
supplied to \code{fetch_files()} as \code{reader} argument. Single cell feature files
as produced by CellProfiler, are stored as Matlab v5.0 \code{.mat} files and
the function \code{read_mat_files()} reads such files using \code{\link[R.matlab:readMat]{R.matlab::readMat()}}
and checks for certain expected attributes and simplifies the read
structure.

The list returned by \code{read_mat_files()} is arranged such that each node
corresponds to a single image and contains a list which is either holding a
single value or a vector of values. For a plate with 16 rows, 24 columns
and 3 x 3 imaging sites this will yield a list of length 3456. Index
linearization is in row-major fashion for both wells and sites.
Furthermore, imaging sites come first such that in this example, the first
three list entries correspond to image row 1 (left to right) of well A1,
the next three entries correspond to row 2 of well A1, images 10 through 12
correspond to row 1 of well A2, etc. Well A2 is located in row 1, column 2
of a plate.
}
\section{openBIS}{

\itemize{
\item \Sexpr[results=rd]{infx::docs_link("dsrg", "listFilesForDataSet")}
}
}

\examples{
\donttest{
  tok <- login_openbis()

  # search for a cell profiler feature data set from plate KB2-03-1I
  search <- search_criteria(
    attribute_clause("type", "HCS_ANALYSIS_CELL_FEATURES_CC_MAT"),
    sub_criteria = search_sub_criteria(
      search_criteria(attribute_clause("code",
                                       "/INFECTX_PUBLISHED/KB2-03-1I")),
      type = "sample"
    )
  )
  ds <- search_openbis(tok, search)

  # list all files of this data set
  all_files <- list_files(tok, ds)
  length(all_files)

  # select some of the files, e.g. all count features per image
  some_files <- all_files[grepl("Image\\\\.Count_",
                                get_field(all_files, "pathInDataSet"))]
  length(some_files)

  # download the selected files
  data <- fetch_files(tok, some_files)

  # the same can be achieved by passing a file_regex argument to
  # fetch_files(), which internally calls list_files() and filters files
  identical(data, fetch_files(tok, ds, file_regex = "Image\\\\.Count_"))

  # all returned data is raw, the reader argument can be used to supply
  # a function that processes the downloaded data
  sapply(data, class)
  data <- fetch_files(tok, some_files, reader = read_mat_files)
  sapply(data, class)

  logout_openbis(tok)
}

}
\seealso{
Other resource listing/downloading functions: \code{\link{fetch_images}},
  \code{\link{list_download_urls}},
  \code{\link{list_features}}
}
\concept{resource listing/downloading functions}
