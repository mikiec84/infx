% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/json-base.R
\name{print.json_class}
\alias{print.json_class}
\alias{[.json_class}
\alias{c.json_class}
\alias{rep.json_class}
\alias{print.json_vec}
\alias{[.json_vec}
\alias{[<-.json_vec}
\alias{[[.json_vec}
\alias{[[<-.json_vec}
\alias{c.json_vec}
\alias{rep.json_vec}
\title{Base generics for JSON objects}
\usage{
\method{print}{json_class}(x, depth = 1L, width = getOption("width"),
  length = 100L, fancy = TRUE, ...)

\method{[}{json_class}(x, i, ...)

\method{c}{json_class}(x, ...)

\method{rep}{json_class}(x, ...)

\method{print}{json_vec}(x, depth = 1L, width = getOption("width"),
  length = 100L, fancy = TRUE, ...)

\method{[}{json_vec}(x, i, ...)

\method{[}{json_vec}(x, i, ...) <- value

\method{[[}{json_vec}(x, i, ...)

\method{[[}{json_vec}(x, i, ...) <- value

\method{c}{json_vec}(x, ...)

\method{rep}{json_vec}(x, ...)
}
\arguments{
\item{x}{Object to print.}

\item{depth}{The maximum recursion depth for printing.}

\item{width}{Number of columns to maximally print.}

\item{length}{Number of lines to maximally print.}

\item{fancy}{Logical switch to enable font styles, colors and UTF box
characters for printing.}

\item{...}{Generic compatibility.}

\item{i}{Index for sub-setting. See \code{\link[base:[]{base::[()}} and
\code{\link[base:[[]{base::[[()}}.}

\item{value}{New values for replacement. See
\code{\link[base:[<-]{base::[<-()}} and
\code{\link[base:[[<-]{base::[[<-()}}.}
}
\description{
Available base generic functions for objects that inherit \code{json_class} are
\code{\link[base:print]{base::print()}}, \code{\link[base:[]{base::[()}}, \code{\link[base:c]{base::c()}} and
\code{\link[base:rep]{base::rep()}} and for \code{json_vec} objects, all of the above in addition
to \code{\link[base:[<-]{base::[<-()}} and
\code{\link[base:[[<-]{base::[[<-()}} are implemented. For further
information on how these class-specific functions differ from their base
counterparts, refer to the details section.
}
\details{
Single bracket sub-setting of \code{json_class} objects preserves
class information, such that the resulting object has the same type but only
a subset of fields. Double bracket sub-setting of \code{json_class} objects
removes the enclosing type, as would be expected considering the list nature
of \code{json_class} objects. Combining or repeating \code{json_class} objects yields
\code{json_vec} objects with the same sub-type. Additionally, when combining
\code{json_class} objects using \code{\link[base:c]{base::c()}}, only \code{json_class} objects with the
same subtype as the first argument are allowed as further arguments.

Analogously to sub-setting of \code{json_class} objects, sub-setting a \code{json_vec}
object with \code{\link[base:[]{base::[()}} returns a \code{json_vec} object
with the same sub type as the one used as input, whereas sub-setting a
\code{json_vec} object with \code{\link[base:[[]{base::[[()}} yields the
selected \code{json_class} object. Replacement operators
\code{\link[base:[<-]{base::[<-()}} and
\code{\link[base:[[<-]{base::[[<-()}} mainly ensure that the objects
being inserted are of the correct sub-type, guaranteeing that all
\code{json_class} members of a given \code{json_vec} object are of the same sub-type.
Combining \code{json_vec} objects with \code{\link[base:c]{base::c()}} is possible whenever the
object passed as first argument has the same sub-type as the objects passed
as further arguments, which additionally are required to be \code{json_vec}
objects as well. Repeating a \code{json_vec} object using \code{\link[base:rep]{base::rep()}}, results
in a \code{json_vec} object of the same sub-type.

Printing of both \code{json_class} and \code{json_vec} objects is inspired by the
\code{ast} printing function of Hadley's \code{lobstr} package and borrows code from
\href{https://git.io/vFMA5}{there} Printing style can either be fancy (colors,
UTF box characters. etc.) or simple (controlled by the \code{fancy} flag) and
several options are available for setting the max printing with/length, as
well as a max recursion depth for nested \code{json_class} objects.
}
\examples{
obj_c <- json_class(a = json_class(b = "c", class = "foo"),
                    d = json_class(e = "f", class = "bar"),
                    class = "foobar")
obj_c
print(obj_c, depth = 2L)
print(obj_c, depth = 2L, length = 4L)
print(obj_c, depth = 2L, fancy = FALSE)

# sub-setting with single brackets preserves class information
obj_c["a"]
# whereas double brackets extract the selected element
obj_c[["a"]]

# vectors of json_class objects are json_vec objects
obj_cc <- rep(obj_c, 2)
identical(obj_cc, c(obj_c, obj_c))

print(obj_cc, depth = 2L, length = 8L)

obj_g <- json_class(a = json_class(b = "g", class = "foo"),
                    d = json_class(e = "h", class = "bar"),
                    class = "foobar")
obj_cg <- c(obj_c, obj_g)

# sub-setting json_vec objects with single brackets yields json_vec objects
class(obj_cg[1])
# and with double brackets, the selected json_class object is extracted
class(obj_cg[[1]])
identical(obj_cg[1], json_vec(obj_cg[[1]]))

# json_vec objects can also be combined using c
obj_i <- json_class(a = json_class(b = "i", class = "foo"),
                    d = json_class(e = "j", class = "bar"),
                    class = "foobar")

obj_cgi <- c(obj_cg, json_vec(obj_i))
length(obj_cgi)

# and repeated using rep
length(rep(obj_cgi, 2))

# additionally replacement operators are available
obj_cg[[2]] <- obj_i
obj_cgi[1:2] <- obj_cg
identical(obj_cgi, c(obj_c, obj_i, obj_i))

}
