% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/feature.R
\name{list_features}
\alias{list_features}
\alias{list_features.FeatureVectorDatasetReference}
\alias{list_features.FeatureVectorDatasetWellReference}
\alias{list_feature_codes}
\alias{list_feature_codes.FeatureVectorDatasetReference}
\alias{list_feature_codes.FeatureVectorDatasetWellReference}
\alias{fetch_features}
\alias{fetch_features.FeatureVectorDatasetReference}
\alias{fetch_features.FeatureVectorDatasetWellReference}
\title{List and download feature data}
\usage{
list_features(token, x, ...)

\method{list_features}{FeatureVectorDatasetReference}(token, x, wells = NULL,
  ...)

\method{list_features}{FeatureVectorDatasetWellReference}(token, x, ...)

list_feature_codes(token, x, ...)

\method{list_feature_codes}{FeatureVectorDatasetReference}(token, x,
  wells = NULL, ...)

\method{list_feature_codes}{FeatureVectorDatasetWellReference}(token, x, ...)

fetch_features(token, x, feature_codes = NA, ...)

\method{fetch_features}{FeatureVectorDatasetReference}(token, x,
  feature_codes = NA, wells = NULL, ...)

\method{fetch_features}{FeatureVectorDatasetWellReference}(token, x,
  feature_codes = NA, ...)
}
\arguments{
\item{token}{Login token as created by \code{login_openbis()}.}

\item{x}{Object to specify the set of feature vector datasets of interest.}

\item{...}{Generic compatibility. Extra arguments will be passed to
\code{\link[=make_requests]{make_requests()}}.}

\item{wells}{Set of \code{WellPosition} objects used to limit the returned
feature data.}

\item{feature_codes}{A character vector of feature codes or NA (all
available feature codes).}
}
\description{
In openBIS, features are datasets that are treated differently from
generic datasets. Briefly put, tabular datasets where columns correspond
to features and rows to wells can be marked as feature datasets which makes
it possible to query openBIS for individual feature values for selected
wells instead of having to download the entire table for a plate. The
relevant object types for handling feature data are
\code{FeatureVectorDatasetReference} and \code{FeatureVectorDatasetWellReference},
where the former represents feature data at plate level and the latter at
well level. The function \code{list_features()} can be used to enumerate
available features and \code{fetch_features()} will download feature data.
}
\details{
Listing of features can be performed by calling \code{list_features()} on
\code{FeatureVectorDatasetReference} or \code{FeatureVectorDatasetWellReference}
objects. Plate-level references of feature datasets can for example be
retrieved using \code{\link[=list_references]{list_references()}} and well-level references are created
whenever a \code{wells} argument is supplied to \code{list_features()}, using the
internal function \code{feat_ds_well_ref()}. The returned objects are of type
\code{FeatureInformation} and each contain code, label and description of each
feature. If for different datasets different sets of features are available,
\code{list_features()} provides the union of the features of all datasets.

Similarly, \code{list_feature_codes()} provides the list of all available
features as character vector or feature codes. As for \code{list_features()},
either plate-level or well-level feature dataset reference may be passed
and if a \code{wells} argument is supplied together with a plate-level
reference, the corresponding well-level references are constructed using
the internal function \code{feat_ds_well_ref()}. If for different datasets
different sets of features are available, \code{list_feature_codes()} provides
the union of the features of all datasets.

For a given set of feature vector datasets, \code{fetch_features()} fetches
feature data for the specified feature codes, or for all available features
in case the argument \code{feature_codes} is not specified (or \code{NA}). The
behavior regarding well selection is the same as in \code{list_features()} and
\code{list_feature_codes()}. Either plate-level or well-level dataset references
are passed and whenever plate-level references are passed in combination
with \code{WellPosition} object, the corresponding well-level references are
created and used. If for different datasets different sets of features are
available, the union of the features of all datasets is searched for. The
returned object is of type \code{FeatureVectorDataset}, which for each entry
contains a \code{FeatureVectorDatasetReference} and a set of \code{FeatureVector}(s),
one for each well.
}
\section{openBIS}{

\itemize{
\item \Sexpr{infx::docs_link("dsrs", "listAvailableFeatures")}
}


\itemize{
\item \Sexpr{infx::docs_link("dsrs", "listAvailableFeatureCodes")}
}


\itemize{
\item \Sexpr{infx::docs_link("dsrs", "loadFeatures")}
}


\itemize{
\item \Sexpr{infx::docs_link("dsrs", "loadFeaturesForDatasetWellReferences")}
}
}

\section{TODO}{
 Even though there exists a constructor for
\code{FeatureVectorDatasetWellReference} objects, which takes two arguments, one
for the corresponding \code{FeatureVectorDatasetReference} object and one for
a \code{WellPosition} objects, this does not work. Furthermore, class information
cannot be supplied as this will cause an error as well (hence the use of
\code{rm_json_class()}). Why the function \code{loadFeaturesForDatasetWellReferences}
behaves this way is currently unclear.
}

\examples{
\dontrun{
  tok <- login_openbis("rdgr2014", "IXPubReview")

  # search for a sample object corresponding to plate KB2-03-1I
  samp <- search_openbis(tok,
                         search_criteria(
                           attribute_clause("/INFECTX_PUBLISHED/KB2-03-1I")
                         ),
                         target_object = "sample")
  # for the plate sample object, list all feature data sets
  feat_ref <- list_references(tok, samp, type = "feature")

  # several data set types can act as feature data sets
  sapply(feat_ref, `[[`, "dataSetType")
  feat_ref <- feat_ref[[7L]]

  # for a feature data set, list all features
  feat_info <- list_features(tok, feat_ref)
  feat_info <- feat_info[c(2L, 6L)]

  # for a feature data set, a set of feature codes and a set of wells,
  #Â retrieve the corresponding feature data
  feats <- fetch_features(tok, feat_ref,
                          feature_codes = sapply(feat_info, `[[`, "code"),
                          wells = well_pos(1:2, 2:3))

  extract_feats <- function(x) {
    c(well_row = x[["wellPosition"]][["wellRow"]],
      well_col = x[["wellPosition"]][["wellColumn"]],
      setNames(as.numeric(x[["values"]]), tolower(x[["featureNames"]])))
  }

  do.call(rbind, lapply(feats, extract_feats))
}

}
