% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/request.R
\name{make_requests}
\alias{make_requests}
\alias{make_request}
\alias{do_requests_serial}
\alias{do_requests_parallel}
\alias{process_json}
\alias{resolve_references}
\title{Construct and issue JSON-RPC requests}
\usage{
make_requests(urls, methods, params, ids = NULL, version = "2.0",
  n_con = 5L, finally = process_json, ...)

make_request(url, method, params, ...)

do_requests_serial(urls, bodies = vector("list", length(urls)),
  n_try = 2L, create_handle = create_default_handle,
  check = check_default_result, finally = identity, ...)

do_requests_parallel(urls, bodies = vector("list", length(urls)),
  n_con = 5L, n_try = 2L, create_handle = create_default_handle,
  check = check_default_result, finally = identity, ...)

process_json(x)

resolve_references(x)
}
\arguments{
\item{params}{A list structure holding the arguments which, converted to
JSON, will be used to call the supplied method. The \code{@type} entries will be
generated from \code{json_class} attributes.}

\item{ids}{Identifier(s) for the JSON-RPC request (defaults to a random
string of length 7). Can be usually be ignored, as only single JSON-RPC
requests are issued per HTTP request.}

\item{version}{JSON-RPC protocol version to be used (defaults to \code{"2.0"}.}

\item{n_con}{The number of simultaneous connections.}

\item{finally}{A function that is applied to the \code{result} entry of a
successful JSON RPC request.}

\item{...}{Further arguments to \code{make_request()} are passed to
\code{make_requests()} and from \code{make_requests()} to \code{do_requests_serial()} or
\code{do_requests_parallel()}.}

\item{url, urls}{Destination url(s), the request is sent to.}

\item{method, methods}{The API method name(s).}

\item{bodies}{Request bodies: a list where each entry is a list with slots
\code{id}, \code{jsonrpc}, \code{method} and \code{params}.}

\item{n_try}{Number of tries each request is performed in case of failed
requests.}

\item{create_handle}{A function that will receive a single entry of the
\code{bodies} list at the time and should return a curl handle created by
\code{\link[curl:new_handle]{curl::new_handle()}}.}

\item{check}{A function that receives both the result of a request and the
corresponding entry of the \code{bodies} list. Is expected to return NULL in
which case the request is retried or a list with an entry named \code{result}.}

\item{x}{A (possibly nested) list structure for which all \code{@type} fields
are turned into class attributes and \code{@id} fields are recursively removed.}
}
\description{
The functions powering all HTTP requests to openBIS are
\code{do_requests_serial()} for sequential calls and \code{do_requests_parallel()}
for asynchronous calls. Constructing requests for the JSON-RPC API of
openBIS is done with the helper function \code{make_requests()} and a wrapper
for single requests is available as \code{make_request()}. This convenience
function calls \code{make_requests()} and returns the first element of the
resulting list of length 1.
}
\details{
Both \code{do_requests_serial()} and \code{do_requests_parallel()} take as \code{urls}
argument a set of urls, either as character vector or list of unevaluated
function calls which will be evaluated using \code{\link[base:eval]{base::eval()}} shortly before
being used (this is used for urls that are only valid for a limited amount
of time). The behavior of \code{do_requests_*()} can be customized with the
three functions passed as arguments \code{create_handle}, \code{check} and \code{finally}
together with the vector (of the same length as \code{urls}) passed as argument
\code{bodies}.

The function passed as \code{create_handle} receives one entry at the time of
the \code{bodies} object and is expected to return a curl handle created by
\code{\link[curl:new_handle]{curl::new_handle()}}. The \code{check} function receives as first argument
the response of a single curl request alongside the corresponding entry of
the \code{bodies} object. This function should check whether the request was
successful or not, e.g. check the HTTP status code, size of the downloaded
file, etc. In case of failure it should return a \code{simpleError} error object,
created by \code{\link[base:simpleError]{base::simpleError()}} and in case of success it should return
the response data, e.g. the \code{content} entry of a curl response. The third
function, \code{finally}, is applied to the object returned by the \code{check}
function (in case of success) and can be used to parse JSON, read a binary
file, etc.

Both \code{do_requests_serial()} and \code{do_requests_parallel()} have the option of
retrying failed requests and the number of allowed retries can be controlled
with the argument \code{n_try}. Furthermore, \code{do_requests_parallel()} offers
control over the number of simultaneous connections using the argument
\code{n_con}. Only \code{n_con} requests are initially added to the curl multi handle
and for each successful one an additional request is added. This
implementation helps with urls that have a limited lifetime.

The function \code{make_requests()} is used to construct JSON-RPC requests. The
arguments \code{methods}, \code{params}, \code{ids} and \code{version} are combined into one
or several request objects according to the JSON-RPC specification which in
turn are passed to \code{do_requests_*()}. The objects passed as \code{methods} and
\code{params} should all be of the same length but in case any are of length 1,
they will be \code{\link[base:rep]{base::rep()}}'ed to the required length. Care has to be taken
that the list passed as \code{params} has the correct degree of nesting. As
\code{make_requests()} iterates over the topmost list level, a single request
should be wrapped in a list such that the topmost list level is on length
\enumerate{
\item The function \code{make_request()} is a wrapper around \code{make_requests()} that
does exactly this.
}

As part of the \code{process_json()} function, which is the default value passed
as \code{finally} argument in \code{make_requests()}, \code{@type} fields are converted
to\code{json_class} attributes, using \code{\link[=as_json_class]{as_json_class()}}. Additionally, \code{@id}
fields, which may be referenced if an objects is used multiple times, are
recursively resolved using \code{\link[=resolve_references]{resolve_references()}} such that each object is
self-contained.
}
\examples{
\donttest{
  tok <- login_openbis()

  # the function list_projects() is implemented as follows
  projects <- make_request(api_url(api_endpoint = "gis"),
                           "listProjects",
                           list(tok))
  print(projects[[1L]])
  # or using make_request(), the params argument has to be a list per
  # request and the first entry of the returned list has to be selected
  proj <- make_requests(api_url(api_endpoint = "gis"),
                        "listProjects",
                        list(list(tok)))
  identical(proj[[1L]][[1L]],
            projects[[1]])

  # without using make_request(), one can achieve the same result by
  # calling do_requests_serial() directly
  proj <- do_requests_serial(api_url(api_endpoint = "gis"),
                             list(
                               list(
                                 id = "foobar",
                                 jsonrpc = "2.0",
                                 method = "listProjects",
                                 params = list(tok)
                               )
                             ),
                             create_handle = infx:::create_request_handle,
                             check = infx:::check_request_result,
                             finally = process_json)
  identical(proj[[1L]][[1L]],
            projects[[1]])

  # the do_requests_*() functions can be used for any HTTP request
  req <- do_requests_serial("https://httpbin.org/headers")
  is.raw(req[[1L]])

  # in order to read the returned binary data, a function can be supplied
  # to do_requests_*() as finally argument

  process_json <- function(x) 
    jsonlite::prettify(rawToChar(x))

  req <- do_requests_serial("https://httpbin.org/headers",
                            finally = process_json)
  req[[1L]]

  # to customize the curl handle, a function can be supplied to
  # do_requests_*() as create_handle argument

  post_handle <- function(x)
    curl::handle_setheaders(
      curl::new_handle(postfields = charToRaw(jsonlite::toJSON(x))),
      "Content-Type" = "application/json"
    )
  process_json <- function(x) 
    jsonlite::fromJSON(rawToChar(x), simplifyDataFrame = FALSE)$json

  data <- list(a = "foo",
               b = "bar")

  req <- do_requests_serial("https://httpbin.org/post",
                            list(data),
                            create_handle = post_handle,
                            finally = process_json)

  # httbin returns POST data, therefore
  identical(data, req[[1L]])

  logout_openbis(tok)
}

}
