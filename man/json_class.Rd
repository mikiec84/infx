% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/json-class.R
\name{json_class}
\alias{json_class}
\alias{as_json_class}
\alias{as.json_class}
\alias{as_json_class.json_class}
\alias{as_json_class.list}
\alias{as_json_class.json_vec}
\alias{as_json_class.default}
\alias{rm_json_class}
\alias{as.list.json_class}
\alias{is_json_class}
\alias{is.json_class}
\alias{check_json_class}
\title{Create and validate JSON class objects}
\usage{
json_class(..., class)

as_json_class(x, ...)

as.json_class(x, ...)

\method{as_json_class}{json_class}(x, ...)

\method{as_json_class}{list}(x, recursive = TRUE, ...)

\method{as_json_class}{json_vec}(x, ...)

\method{as_json_class}{default}(x, force = FALSE, ...)

rm_json_class(x, recursive = TRUE, restore_type = TRUE)

\method{as.list}{json_class}(x, keep_asis = TRUE, recursive = !keep_asis,
  restore_type = !keep_asis, ...)

is_json_class(x)

is.json_class(x)

check_json_class(x, recursive = TRUE)
}
\arguments{
\item{...}{Generic compatibility.}

\item{class}{JSON sub-class name.}

\item{x}{Object to process.}

\item{recursive}{Recursively apply the function.}

\item{force}{Suppress error when casting an object to \code{json_class} that
cannot be converted.}

\item{restore_type}{When removing the \code{json_class} information from an
object, whether to preserve the subclass attribute as \code{@type} filed.}

\item{keep_asis}{Used in \code{as.list()}, if \code{TRUE}, the \code{json_class} object
is returned as-is, if \code{FALSE}, class attributes may be dropped/written to
the list structure into the \code{@type} field.}
}
\description{
To communicate object type information via JSON to the Jackson-powered
openBis interface, the \code{@type} field is used. Data received from openBis is
recursively stripped of \code{@type} fields and the type information is saved as
class attribute. Such objects also have the class \code{json_class} added. The
function \code{as_json_class()} (or its alias \code{as.json_class()}) powers this
recursive conversion of a list with filed \code{@type} into a \code{json_class}
object. The constructor \code{json_class()} is available for non-recursive
instantiation of \code{json_class} objects.
}
\details{
The action of \code{as_json_class()} is reversed by \code{rm_json_class()}. This
removes both the \code{json_class} class attribute and the JSON class attribute
itself, which is subsequently written to a \code{@type} filed. This preserving
of type information can be disabled, by setting the argument \code{restore_type}
to \code{FALSE}. Furthermore, the action can be applied recursively with the
argument \code{recursive}. The function \code{as.list()} can also be used to perform
the above actions, but with default arguments, it does nothing, as
functions such as \code{\link[base:sapply]{base::sapply()}} and \code{\link[base:lapply]{base::lapply()}}, call \code{as.list()}.

JSON class objects have custom sub-setting and printing functions available.
Sub-setting of JSON objects that preserve class and \code{json_class}
attributes. This is useful when objects are created from openBIS results
which are subsequently used in further queries, but the constructors they
are passed to require only a subset of the fetched fields.

The functions \code{is_json_class()} tests whether an object is a proper JSON
class object, meaning that:
\itemize{
\item it is a list
\item it inherits \code{json_class}
\item the last class attribute is \code{json_class}
\item apart from \code{json_class} there exists at least one more class attribute
}

In order to recursively test a \code{json_class} object for being properly
formed, the function \code{check_json_class()} can be used. This recurses through
a list structure and whenever an object inherits from \code{json_class} it is
tested with \code{is_json_class()}.
}
\examples{
lst <- list(`@type` = "foobar",
            a = list(`@type` = "foo", b = "c"),
            d = list(`@type` = "bar", e = "f"))

cls <- as_json_class(lst)
print(cls, depth = 2)

is_json_class(cls)
get_subclass(cls)

# recursive validation of json_class objects with check_json_class()
attr(cls[["d"]], "class") <- "json_class"
is_json_class(cls)
check_json_class(cls)

# as_json_class() is idempotent
identical(as_json_class(lst), as_json_class(as_json_class(lst)))

# rm_json_class() reverses the action of as_json_class()
identical(lst, rm_json_class(as_json_class(lst)))

# json_class objects can be instantiated using the constructor json_class()
identical(as_json_class(lst), 
          json_class(a = json_class(b = "c", class = "foo"),
                     d = json_class(e = "f", class = "bar"),
                     class = "foobar"))

cls <- as_json_class(lst)

# the default of as.list does nothing
identical(cls, as.list(cls))
# this can be disabled, by setting keep_asis to FALSE
identical(lst, as.list(cls, keep_asis = FALSE))
# further options are disabling recursive action
as.list(cls, keep_asis = FALSE, recursive = FALSE)
# and dropping type information
as.list(cls, keep_asis = FALSE, recursive = FALSE, restore_type = FALSE)

}
